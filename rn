#!/bin/bash
#
#   rn: rename files with regex.
#   
#   Copyright (C) <2019>  <Boyu Mi(miboyu@yeah.net)>
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#   Author  : Boyu Mi
#   E-mail  : miboyu@yeah.net
#   Date    : 2019/09/14
#   Version : 1.0.2
#   
#   Change Log:
#       1.0.2 (2019/09/14)
#           Change to extended regex "sed -E ...".
#           Support more escape characters \d \D etc.
#           Add option --regex to show quick reference of regex.
#
#       1.0.1 (2019/09/13)
#           Fix some bugs.
#           Add more verbose information.
#
#       1.0.0 (2019/09/12)
#           Initial version.
#   

##=============================================================================
## FUNCTIONS
##=============================================================================
# Simplified colorful echo
function cecho()
{
    # cecho "contents to show" [foreground color] [background color]

    function color_code()
    {
        case "$1" in
            black) return 0 ;;
            red) return 1 ;;
            green) return 2 ;;
            yellow) return 3 ;;
            blue) return 4 ;;
            purple) return 5 ;;
            skyblue) return 6 ;;
            white) return 7;;
            *) return 8 ;;
        esac
    }
    color_code "$2"; fore=$?
    color_code "$3"; back=$?
    if [[ $fore -lt 8 ]]; then
        if [[ $back -lt 8 ]]; then
            echo -n -e "\033[4${back};3${fore}m${1}\033[0m"
        else
            echo -n -e "\033[3${fore}m${1}\033[0m"
        fi
    else
        echo -n -e "$1"
    fi
}

##=============================================================================
function print_error()
{
    # print_error "message"
    cecho "rn: $1\n" red
}

##=============================================================================
function print_verbose()
{
    # print_verbose "head" "tail"
    cecho "$1" skyblue
    cecho "$2\n"
}

##=============================================================================
function print_filename()
{
    # print_filename "filename"
    if [[ ! -e "$1" ]]; then
        cecho "$1" white        # white for non-existing
    elif [[ -f "$1" ]]; then
        cecho "$1" yellow       # yellow for regular file
        [[ -x "$1" ]] && cecho "*" yellow 
    elif [[ -d "$1" ]]; then
        cecho "$1" blue        # blue for directory
        [[ ${1:0-1} != "/" ]] && cecho "/" blue
    elif [[ -L "$1" ]]; then
        cecho "$1@" green       # green for symbolic link
    else
        cecho "$1" red          # red for other types to show warning
        if [[ -p "$1" ]]; then
            cecho "|" red     
        elif [[ -S "$1" ]]; then
            cecho "=" red     
        fi
    fi
}

##=============================================================================
function number_check()
{                                
    # check whether the given argument is a number
    expr $1 + 0 &> /dev/null    
    return $?
}

##=============================================================================
function print_help() 
{
    echo 'Rename files with regex.

Usage:
    rn [options] [-o origin -s substitute] [files]

Options:
    -o | --origin ptn   the original name pattern (support regex)
    -s | --substi ptn   the substitutional name pattern (support regex)
    -p | --space        filename contains space
    -f | --force        force mode, overwrite existing target
    -t | --test         test mode, show the results without real action 
    -r | --run          run mode, execute the renaming process
    -q | --quiet        quiet mode, show least information
    -v | --verbose      verbose mode, show most information
    -l | --lower        to lower case, use -f if the name is case insensitive
    -u | --upper        to upper case, use -f if the name is case insensitive
    -n | --number=[ch]  "ch" will be replaced by a serial number in substitute,
                        the default "ch" is "#"
         --nbegin #     beginning number when -n is used, defaulted as 1
         --nstep #      step number when -n is used, defaulted as 1 
         --nwidth #     least width of the serial number when -n is used,
                        defaulted as 2 (eg: 1 will be 01)
    -A | --all          all types of file will be renamed
    -F | --file         regular file will be renamed
    -D | --dir          directory will be renamed
    -B | --block        block device file will be renamed
    -C | --char         character device file will be renamed
    -S | --socket       socket file will be renamed
    -P | --pipe         pipe file will be renamed
    -L | --link         symbolic link file will be renamed
         --help         show this help information
         --version      show version information
         --regex        show quick reference of regex
         --example      show examples
         --return-code  show return codes

The "origin" and "substitute" should be given at the same time for command "sed"
to do the substitution. If both were omitted, option --lower and --upper can be 
used to transform letter case of the "files", and option --number (together with 
number settings --nbegin, --nstep, and --nwidth) can be used to add serial 
number to the front of the "files".

If the "files" is omitted, the results of command "ls" is used. If there are 
spaces in filenames, use option --space, and each filename should occupy one 
line for the space " " cannot be used as Internal Field Separator (IFS) anymore.
If the "files" has parent path (contains "/"s), only the filename part would be
renamed, and the filename part could be file, dir, and so on.

Test mode is a good way to examine the renaming effect. The following alias is 
strongly suggested to avoid mistakes since there is no roll-back option yet.
        alias rn="rn -t"
Once it might work right, option --run could be used to start the operation.

Quiet mode will print no information except for the error messages. Verbose mode
will print as much information as possible, which can be used to check the inner
status. If there is no --quiet or --verbose option, the normal mode only print
necessary information.

Some options might conflict, like --test & --run, --quiet & --verbose, --lower
& --upper, only the last one takes effect. For example, "rn -u -l" means "to
lower case"

The file type options (-FDBCSPL) are used to filter unexpected files. It can
also be completed in argument "files" before passing in. If no file type option 
is given, the default types (file, dir, and link) are used.

Any bugs, questions, or suggestions, please contact Boyu Mi(miboyu@yeah.net).
'
}

##=============================================================================
function print_version()
{
    echo 'rn 1.0.2 (2019/09/14)
Copyright (c) 2019 Boyu Mi(miboyu@yeah.net)
'
}

##=============================================================================
function print_regex()
{
    echo 'Quick reference for regular expression:

  ===========   ================================================
    MetaChar    Meaning
  -----------   ------------------------------------------------
       \        escape character
  -----------   ------------------------------------------------
       .        match any character except \n
      []        match any character in []
      [-]       match any character in [], range form
      [^]       match any character not in [^]
  -----------   ------------------------------------------------
       ?        repeat 0 or once
       +        repeat once or more times
       *        repeat 0 or more times
      {n}       repeat n times
      {n,}      repeat n or more times
      {n,m}     repeat n to m times
      {,m}      repeat 0 to m times
  -----------   ------------------------------------------------
       |        left side or right side
      ()        group
      \1        the 1st captured group, there are also \2, \3...
  -----------   ------------------------------------------------
       ^        anchor head of a line
       $        anchor tail of a line
      \<        anchor head boundary of a word
      \>        anchor tail boundary of a word
      \b        anchor word boundary
      \B        anchor non word boundary
  -----------   ------------------------------------------------
  [[:digit:]]   any digit number
  [[:alnum:]]   any letter or number
  [[:alpha:]]   any letter
  [[:lower:]]   any lowercase letter
  [[:upper:]]   any uppercase letter
  [[:punct:]]   any punctuation
  [[:graph:]]   any graphical character
  [[:space:]]   any space character
  -----------   ------------------------------------------------
      \d        the same as [[:digit:]]
      \D        the same as [^[:digit:]]
      \a        the same as [[:alpha:]]
      \A        the same as [^[:alpha:]]
      \l        the same as [[:lower:]]
      \L        the same as [^[:lower]]
      \u        the same as [[:upper:]]
      \U        the same as [^[:upper:]]
      \s        the same as [[:space:]]
      \S        the same as [^[:space:]]
      \w        the same as [_[:alnum:]]
      \W        the same as [^_[:alnum:]]
  ===========   ================================================
'
}

##=============================================================================
function print_example()
{
    echo 'Examples:
# 1.Change all the filenames at pwd to UPPER CASE
        $ rn -u

# 2.Change the names of .txt files to lower case
        $ rn -l *.txt

# 3.Add serial number at the beginning 
        $ rn -n *.jpg
For example, "a.jpg" "b.jpg" will become "01a.jpg" "02b.jpg"

# 4.Add serial number at given position
        $ rn -n -o "\.jpg" -s "-#.jpg" 
For example, "a.jpg" "b.jpg" will become "a-01.jpg" "b-02.jpg"

# 5.Remove a certain part in filenames
        $ rn -o "-.." -s ""
For example, "a-01.jpg" "b-02.jpg" will become "a.jpg" "b.jpg"

# 6.Add "-" between a letter and a number
        $ rn -o "(\a)(\d)" -s "\1-\2"
'
}

##=============================================================================
function print_return_code()
{
    echo 'Return code and meaning:
    0   Success
    1   Argument error
    2   Internal error
    3   Invalid "origin" and "substitute"
    4   Parameter type error
'
}


##=============================================================================
##=============================================================================
## Parsing the command line arguments with "getopt"

# define short arguments and long arguments, see "print_help()"
short_args="o:s:pftrqvlun::AFDBCSPL"
long_args="origin:,substi:,space,force,test,run,quiet,verbose,lower,upper,
           number::,nbegin:,nstep:,nwidth:,
           all,file,dir,block,char,socket,pipe,link,
           help,version,regex,example,return-code"

# store all the arguments in $ARGS
ARGS=$(getopt -o "$short_args" -l "$long_args" -- "$@")
if [[ $? -ne 0 ]]; then     # error
    print_error 'argument error, try "rn --help" for help information'
    exit 1
fi

# store $ARGS to $1, $2, ...
eval set -- "${ARGS}"

##=============================================================================
## Get the options and/or parameters  

# if the only part is --, no argument means help
if [[ $# -eq 1 ]]; then     
    HELP="yes"
fi

# message level: 0 for quiet, 1 for normal, 2 for verbose
MSGLEVEL=1      

# traverse the $ARGS
while true; do
    case "$1" in
        -o|--origin) ORIGIN="$2"; shift 2 ;;
        -s|--substi) SUBSTI="$2"; shift 2 ;;
        -p|--space) SPACE="yes"; shift ;;
        -f|--force) FORCE="yes"; shift ;;
        -t|--test) TEST="yes"; shift ;;
        -r|--run) unset TEST; shift ;;
        -q|--quiet) MSGLEVEL=0; shift ;;
        -v|--verbose) MSGLEVEL=2; shift ;;
        -l|-lower) LOWER="yes"; unset UPPER; shift ;;
        -u|--upper) UPPER="yes"; unset LOWER; shift ;;
        -n|--number)
            case "$2" in
                "") NUMBER="#" ;;
                *) NUMBER="$2" ;;
            esac
            shift 2 ;;
        --nbegin) NBEGIN="$2"; shift 2 ;;
        --nstep) NSTEP="$2"; shift 2 ;;
        --nwidth) NWIDTH="$2"; shift 2 ;;
        -A|--all) ALL="yes"; shift ;;
        -F|--file) FILE="yes"; shift ;;
        -D|--dir) DIR="yes"; shift ;;
        -B|--block) BLOCK="yes"; shift ;;
        -C|--char) CHAR="yes"; shift ;;
        -S|--socket) SOCKET="yes"; shift ;;
        -P|--pipe) PIPE="yes"; shift ;;
        -L|--link) LINK="yes"; shift ;;
        --help) HELP="yes"; shift ;;
        --version) VERSION="yes"; shift ;;
        --regex) REGEX="yes"; shift ;;
        --example) EXAMPLE="yes"; shift ;;
        --return-code) RETURNCODE="yes"; shift ;;
        --) 
            shift; FILES="$@"; break ;;
        *) 
            print_error 'internal error, parsing arguments failed'
            exit 2 ;;
    esac
done

##=============================================================================
# show help
if [[ $HELP ]]; then
    print_help
    exit 0
fi

# show version
if [[ $VERSION ]]; then
    print_version
    exit 0
fi

# show regex
if [[ $REGEX ]]; then
    print_regex
    exit 0
fi

# show example
if [[ $EXAMPLE ]]; then
    print_example
    exit 0
fi

# show return code
if [[ $RETURNCODE ]]; then
    print_return_code
    exit 0
fi

##=============================================================================
# origin and substitute check
if [[ $ORIGIN || $SUBSTI ]]; then
    [[ $MSGLEVEL -ge 2 ]] && \
        print_verbose "user defined substitution: " "\"$ORIGIN\" --> \"$SUBSTI\""
    # the following escape characters are not supported in "sed"
    ORIGIN=${ORIGIN//\\d/[[:digit:]]}         # \d for digit numbers
    ORIGIN=${ORIGIN//\\D/[^[:digit:]]}        # \D for non digit numbers
    ORIGIN=${ORIGIN//\\u/[[:upper:]]}         # \u for uppercase letters
    ORIGIN=${ORIGIN//\\U/[^[:upper:]]}        # \U for non uppercase letters
    ORIGIN=${ORIGIN//\\l/[[:lower:]]}         # \l for lowercase letters
    ORIGIN=${ORIGIN//\\L/[^[:lower:]]}        # \L for non lowercase letters
    ORIGIN=${ORIGIN//\\a/[[:alpha:]]}         # \a for letters
    ORIGIN=${ORIGIN//\\A/[^[:alpha:]]}        # \A for non letters
    USESED="yes"    # use "sed" to substitute the origin
else 
    [[ $MSGLEVEL -ge 2 ]] && \
        print_verbose "no user defined substitution"
    unset USESED    # no "sed" substitution
fi

##=============================================================================
## serial number setting
if [[ $NUMBER ]]; then
    [[ $MSGLEVEL -ge 2 ]] && \
        print_verbose "serial number substitution: " "$NUMBER"
    NBEGIN=${NBEGIN:-1}     # default 1
    number_check $NBEGIN
    if [[ $? -ne 0 ]]; then
        print_error 'parameter for option --nbegin is not a number.'
        exit 4
    else
        [[ $MSGLEVEL -ge 2 ]] && \
            print_verbose "beginning serial number: " "$NBEGIN"
    fi
    NSTEP=${NSTEP:-1}       # default 1
    number_check $NSTEP
    if [[ $? -ne 0 ]]; then
        print_error 'parameter for option --nstep is not a number.'
        exit 4
    else
        [[ $MSGLEVEL -ge 2 ]] && \
            print_verbose "serial number step: " "$NSTEP"
    fi
    NWIDTH=${NWIDTH:-2}     # default 2
    number_check $NWIDTH
    if [[ $? -ne 0 ]]; then
        print_error 'parameter for option --nwidth is not a number.'
        exit 4
    else
        [[ $MSGLEVEL -ge 2 ]] && \
            print_verbose "serial number width: " "$NWIDTH"
    fi
else
    unset NBEGIN
    unset NSTEP
    unset NWIDTH
fi

##=============================================================================
# file types to rename
if [[ $ALL ]]; then
    [[ $MSGLEVEL -ge 2 ]] && \
        print_verbose "renaming file types: " "all"
    FILE="yes"; DIR="yes"; LINK="yes"
    BLOCK="yes"; CHAR="yes"; SOCKET="yes"; PIPE="yes"
elif [[ -z $FILE && -z $DIR && -z $BLOCK && -z $CHAR &&\
      -z $SOCKET && -z $PIPE && -z $LINK ]]; then
    [[ $MSGLEVEL -ge 2 ]] && \
        print_verbose "renaming file types: " "file dir link"
    FILE="yes"; DIR="yes"; LINK="yes"   # 3 default types
elif [[ $MSGLEVEL -ge 2 ]]; then
    cecho "renaming file types: " skyblue
    [[ $FILE ]] && cecho "file "
    [[ $DIR ]] && cecho "dir "
    [[ $LINK ]] && cecho "link "
    [[ $BLOCK ]] && cecho "block "
    [[ $CHAR ]] && cecho "char "
    [[ $SOCKET ]] && cecho "socket "
    [[ $PIPE ]] && cecho "pipe "
    echo
fi

##=============================================================================
# files check, if empty, get all items in pwd
if [[ -z $FILES ]]; then
    FILES=$(/bin/ls -A1)    
    # -A: all but . and ..
    # -1: one item each line, in case that there are spaces in filename
fi
[[ $MSGLEVEL -ge 2 ]] && print_verbose "renaming items:\n" "$FILES"

##=============================================================================
##=============================================================================

# if space in filename, save default IFS and set new IFS
if [[ $SPACE ]]; then
    OLDIFS="$IFS"
    IFS=$'\n'       # in case that space is part of the filename
fi

## renaming process
for old_name in  ${FILES} ; do    ### NOTE: $FILES cannot be quoted, 
                                  ###   or it will be treated as one item
    # transform \ to /
    old_name=${old_name//\\/\/}

    [[ $MSGLEVEL -ge 2 ]] && \
        print_verbose "\ncurrent: " "$(print_filename "$old_name")"

    # existence check
    if [[ ! -e "$old_name" ]]; then
        [[ $MSGLEVEL -ge 1 ]] && echo "\"$old_name\" not found"
        continue
    else
        # if the last char is '/', remove it
        if [[ ${old_name:0-1} == "/" ]]; then
            old_name=${old_name%/*}
        fi
        # get the parent path
        parent=${old_name%/*}   # remove the last / and its right part
        if [[ "$parent" == "$old_name" ]]; then 
            unset parent            # if there is no parent, unset it
        else
            parent="${parent}/"     # else, add / to the end
        fi
        # get the filename
        old_filename=${old_name##*/}    # remove the last / and its left part
    fi

    # file type check
    if [[ -f "$old_name" ]] && [[ -z $FILE ]]; then
        [[ $MSGLEVEL -ge 2 ]] && \
            print_verbose "skip file: " "\"$old_name\""
        continue
    fi
    if [[ -d "$old_name" ]] && [[ -z $DIR ]]; then
        [[ $MSGLEVEL -ge 2  ]] && \
            print_verbose "skip directory: " "\"$old_name\""
        continue
    fi
    if [[ -b "$old_name" ]] && [[ -z $BLOCK ]]; then
        [[ $MSGLEVEL -ge 2  ]] && \
            print_verbose "skip block device: " "\"$old_name\""
        continue
    fi
    if [[ -c "$old_name" ]] && [[ -z $CHAR ]]; then
        [[ $MSGLEVEL -ge 2  ]] && \
            print_verbose "skip character device: " "\"$old_name\""
        continue
    fi
    if [[ -S "$old_name" ]] && [[ -z $SOCKET ]]; then
        [[ $MSGLEVEL -ge 2  ]] && \
            print_verbose "skip socket file: " "\"$old_name\""
        continue
    fi
    if [[ -p "$old_name" ]] && [[ -z $PIPE ]]; then
        [[ $MSGLEVEL -ge 2  ]] && \
            print_verbose "skip pipe file: " "\"$old_name\""
        continue
    fi
    if [[ -L "$old_name" ]] && [[ -z $LINK ]]; then
        [[ $MSGLEVEL -ge 2  ]] && \
            print_verbose "skip link file: " "\"$old_name\""
        continue
    fi

    # name substitution
    if [[ $USESED ]]; then
        new_filename=$(echo "$old_filename" | sed -E "s/$ORIGIN/$SUBSTI/g")
        if [[ $? -ne 0 ]]; then
            print_error 'invalid "origin" and "substitute"'
            exit 3
        fi
    else
        new_filename="$old_filename"
    fi

    # no user "origin" and "substitute" means rename all
    # else, only changed filenames would be further renamed
    if [[ -z $USESED || ( "$new_filename" != "$old_filename" ) ]]; then
        # case check
        if [[ $UPPER ]]; then
            [[ $MSGLEVEL -ge 2  ]] && \
                print_verbose "case change: " "to upper"
            new_filename=${new_filename^^}
        elif [[ $LOWER ]]; then
            [[ $MSGLEVEL -ge 2  ]] && \
                print_verbose "case change: " "to lower"
            new_filename=${new_filename,,}
        fi

        # serial number
        if [[ $NUMBER ]]; then
            number=$(printf "%0${NWIDTH}d" $NBEGIN)
            [[ $MSGLEVEL -ge 2  ]] && \
                print_verbose "serial number: " "$number"
            if [[ $USESED ]]; then
                new_filename=${new_filename//"$NUMBER"/"$number"}
            else
                new_filename="${number}${new_filename}"
            fi
            NBEGIN=$((NBEGIN + NSTEP))
        fi
    fi

    # get the full new name
    new_name="${parent}${new_filename}"

    # no renaming if the name doesn't change
    if [[ "$old_name" == "$new_name" ]]; then
        [[ $MSGLEVEL -ge 2 ]] && \
            print_verbose "unchanged filename: " "$old_name"
        [[ -z $USESED && $NUMBER ]] && NBEGIN=$((NBEGIN - NSTEP))
        continue
    fi

    # print information
    if [[ $MSGLEVEL -ge 1 ]]; then
        cecho "rn: " skyblue; print_filename "$old_name"
        cecho " --> " skyblue; print_filename "$new_name\t"
    fi

    # rename
    if [[ $TEST ]]; then    # no real action
        [[ $MSGLEVEL -ge 1 ]] && cecho "test\n" skyblue
        continue
    else                    # rename
        # target existence check
        if [[ -e "$new_name" ]]; then 
            # dir -- non-dir check
            if [[ (-d "$old_name") && (! -d "$new_name") ]]; then
                [[ $MSGLEVEL -ge 1 ]] && cecho "dir -> non-dir failure\n" red
                [[ $NUMBER ]] && NBEGIN=$((NBEGIN - NSTEP))
                continue
            elif [[ (! -d "$old_name") && (-d "$new_name") ]]; then
                [[ $MSGLEVEL -ge 1 ]] && cecho "non-dir -> dir failure\n" red
                [[ $NUMBER ]] && NBEGIN=$((NBEGIN - NSTEP))
                continue
            fi
            # force or prompt
            if [[ $FORCE ]]; then           # force mode
                [[ $MSGLEVEL -ge 2 ]] && cecho "overwrite\t" skyblue
                mv "$old_name" "$new_name"
            else                            # prompt user to decide
                cecho "overwrite? (y/n): "
                read yes_no
                if [[ $yes_no == 'y' ]]; then
                    mv "$old_name" "$new_name"
                else
                    [[ $MSGLEVEL -ge 1 ]] && cecho "cancelled\n" purple
                    continue
                fi
            fi
        # not exist, rename directly
        else        
            mv "$old_name" "$new_name"
        fi

        # status check
        if [[ $? -eq 0 ]]; then
            [[ $MSGLEVEL -ge 1 ]] && cecho "OK\n" purple
        else
            [[ $MSGLEVEL -ge 1 ]] && cecho "failed\n" red
        fi
    fi

done

if [[ $SPACE ]]; then
    IFS="$OLDIFS"       # get back default IFS
fi

##=============================================================================
##=============================================================================
## THE END
